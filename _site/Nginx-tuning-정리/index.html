<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="Ohjongsung's Dev Story" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="Ohjongsung's Dev Story" /> <title> Nginx Tuning 정리 - Ohjongsung's Dev Story </title> <link rel="alternate" href="http://localhost:4000/Nginx-tuning-%EC%A0%95%EB%A6%AC/" hreflang="en-US" /> <link rel="canonical" href="http://localhost:4000/Nginx-tuning-%EC%A0%95%EB%A6%AC/" /> <meta name="description" content="개발 블로그입니다. @github." /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Nginx Tuning 정리 | Ohjongsung's Dev Story" /> <meta property="og:title" content="Nginx Tuning 정리 | Ohjongsung's Dev Story" /> <meta property="og:type" content="website" /> <meta property="og:url" content="http://localhost:4000/Nginx-tuning-%EC%A0%95%EB%A6%AC/" /> <meta property="og:description" content="개발 블로그입니다. @github." /> <meta property="og:image" content="http://localhost:4000/assets/img/ogp.png" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Nginx Tuning 정리 | " /> <meta name="twitter:url" content="http://localhost:4000/Nginx-tuning-%EC%A0%95%EB%A6%AC/" /> <meta name="twitter:site" content="@" /> <meta name="twitter:creator" content="@" /> <meta name="twitter:description" content="개발 블로그입니다. @github." /> <meta name="twitter:image" content="http://localhost:4000/assets/img/ogp.png" /> <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ohjongsung's Dev Story" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="light" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="https://github.com/ohjongsung" target="_blank" rel="noopener" >github</a ><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">Nginx Tuning 정리</h1> <div class="post-meta"> <time datetime="2020-04-11T00:00:00+09:00" itemprop="datePublished"> 2020-04-11 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Ohjongsung's Dev Story</span> </span> <time hidden datetime="" itemprop="dateModified"> Apr 11, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">Ohjongsung's Dev Story</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><h2 id="the-backlog-queue">The Backlog Queue</h2> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <h2 id="the-backlog-queue"> <a href="#the-backlog-queue" class="anchor-head"></a> The Backlog Queue </h2> <h3 id="netcoresomaxconn"> <a href="#netcoresomaxconn" class="anchor-head"></a> net.core.somaxconn </h3> <p>NGINX가 수락하도록 대기열에 넣을 수 있는 최대 연결 수 기본값은 종종 매우 낮으며, NGINX는 연결을 매우 빠르게 받아들이기 때문에 일반적으로 허용되지만, 웹 사이트가 많은 트래픽을 경험할 경우 이를 늘려야 한다. listen()으로 바인딩 된 서버 소켓에서 accept()를 기다리는 소켓 개수에 관련된 커널 파라미터</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysctl net.core.somaxconn
<span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.somaxconn<span class="o">=</span><span class="s2">"1024"</span>
</code></pre></div></div> <p>이 값을 512보다 큰 값으로 설정하려면 백 로그 매개 변수를 NGINX listen 지시문으로 변경</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listen <span class="k">*</span>:8080 <span class="nv">backlog</span><span class="o">=</span>16384<span class="p">;</span>
</code></pre></div></div> <h3 id="netipv4tcp_max_syn_backlog"> <a href="#netipv4tcp_max_syn_backlog" class="anchor-head"></a> net.ipv4.tcp_max_syn_backlog </h3> <p>net.core.somaxconn’이 accept()을 기다리는 ESTABLISHED 상태의 소켓(즉, connection completed)을 위한 queue라면, ‘net.ipv4.tcp_max_syn_backlog’는 SYN_RECEIVED 상태의 소켓(즉, connection incompleted)을 위한 queue</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysctl net.ipv4.tcp_max_syn_backlog
<span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.ipv4.tcp_max_syn_backlog<span class="o">=</span><span class="s2">"1024"</span>
</code></pre></div></div> <h3 id="netcorenetdev_max_backlog"> <a href="#netcorenetdev_max_backlog" class="anchor-head"></a> net.core.netdev_max_backlog </h3> <p>CPU에 전달되기 전에 패킷이 네트워크 카드로 버퍼링되는 속도. 값을 늘리면 대역폭이 많은 컴퓨터의 성능이 향상될 수 있다.</p> <p>각 네트워크 장치 별로 커널이 처리하도록 쌓아두는 queue의 크기를 설정한다. 커널의 패킷 처리 속도가 이 queue에 추가되는 패킷의 인입 속도보다 떨어진다면 미처 queue에 추가되지 못한 패킷들은 버려진다.</p> <p>이 커널 파라미터도 trade-off 관계가 메모리 사용량 밖에 없으므로, 적당히 증가시켜두는 것도 괜찮다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysctl net.core.netdev_max_backlog
<span class="nb">sudo </span>sysctl <span class="nt">-w</span> net.core.netdev_max_backlog<span class="o">=</span><span class="s2">"30000"</span>
</code></pre></div></div> <h2 id="file-descriptors"> <a href="#file-descriptors" class="anchor-head"></a> File Descriptors </h2> <p>파일 설명자는 무엇보다도 연결과 파일을 여는 데 사용되는 운영 체제 자원이다. NGINX는 연결당 최대 2개의 파일 설명자를 사용할 수 있다. 예를 들어, NGINX가 프록시를 사용하는 경우 일반적으로 클라이언트 연결에는 하나의 파일 설명자를 사용하고 프록시 서버에 대한 연결에는 다른 파일 설명자를 사용하지만 HTTP keepalive를 사용하는 경우에는 이 비율이 훨씬 낮다.</p> <p>리눅스를 비롯한 일반적인 유닉스에서 소켓은 마치 파일과 같은 취급을 받는다. 전체 시스템에서 가질 수 있는 파일 개수가 제한이 있다면, 당연히 소켓의 전체 개수에 영향을 끼친다.</p> <p>리눅스에서 전체 시스템이 가질 수 있는 최대 파일 개수 제한은 ‘<code class="language-plaintext highlighter-rouge">fs.file-max</code>’ 커널 파라미터에서 설정 된다. 이 값은 일반적으로 적당히 큰 값이 설정되어 있으므로, 웬만하면 손 볼 일이 없을 것입니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 최대 파일 개수 제한</span>
sysctl fs.file-max

<span class="c"># 현재 열려있는 파일 현황</span>
sysctl fs.file-nr
</code></pre></div></div> <p>프로세스별 제한 설정인 user limit 값을 살펴봐야 한다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ulimit</span> <span class="nt">-a</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vi /etc/security/limits.conf

<span class="k">*</span> soft    nofile  128000
<span class="k">*</span> hard    nofile  128000
</code></pre></div></div> <h2 id="ephemeral-ports"> <a href="#ephemeral-ports" class="anchor-head"></a> Ephemeral Ports </h2> <p>NGINX가 프록시로 작동하는 경우 업스트림 서버에 대한 각 연결은 임시 포트 또는 임시 포트를 사용</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/sys/net/ipv4/ip_local_port_range
sysctl <span class="nt">-w</span> net.ipv4.ip_local_port_range<span class="o">=</span><span class="s2">"1024 65535"</span>
</code></pre></div></div> <h1 id="nginx-configuration"> <a href="#nginx-configuration" class="anchor-head"></a> NGINX Configuration </h1> <h2 id="worker-processes"> <a href="#worker-processes" class="anchor-head"></a> Worker Processes </h2> <p>최적의 값은 CPU 코어 수, 데이터를 저장하는 하드 디스크 드라이브의 수, 로드 패턴을 포함한 많은 요인에 따라 결정된다. 의심스러울 때, 사용 가능한 CPU 코어 수로 설정하는 것이 좋은 시작일 것이다</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_processes number | auto<span class="p">;</span>
worker_processes 1<span class="p">;</span>
</code></pre></div></div> <h2 id="worker-connections"> <a href="#worker-connections" class="anchor-head"></a> Worker Connections </h2> <p>작업자 프로세스에서 열 수 있는 최대 동시 연결 수를 설정한다. 이 숫자는 클라이언트와의 연결뿐만 아니라 모든 연결(예: 프록시 서버와의 연결 등)을 포함한다는 점을 유념해야 한다. 또 다른 고려사항은 동시 접속의 실제 횟수가 worker_rlimit_nofile이 변경할 수 있는 열린 파일의 최대 수에 대한 현재 제한을 초과할 수 없다는 것이다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_connections number<span class="p">;</span>
worker_connections 512<span class="p">;</span>
</code></pre></div></div> <p>작업자 프로세스에 대한 최대 열린 파일 수 (RLIMIT_NOFILE)에 대한 제한을 변경합니다. 기본 프로세스를 다시 시작하지 않고 한계를 늘리는 데 사용됩니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_rlimit_nofile number<span class="p">;</span>
</code></pre></div></div> <h2 id="keepalive-requests"> <a href="#keepalive-requests" class="anchor-head"></a> Keepalive Requests </h2> <p>단일 keep-alive 연결을 통해 서비스할 수 있는 요청의 최대 수를 설정한다. 최대 요청 횟수가 이루어진 후에는 연결이 종료된다. 연결당 메모리 할당을 해제하려면 정기적으로 연결을 닫아야 한다. 따라서, 너무 많은 최대 요청 수를 사용하면 메모리 사용량이 과도하게 증가하여 권장되지 않을 수 있다.</p> <p>기본값은 100이지만 일반적으로 단일 클라이언트에서 많은 요청을 보내는 부하 발생 도구를 사용하여 테스트하는 데 훨씬 더 높은 값이 특히 유용할 수 있다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keepalive_requests number<span class="p">;</span>
keepalive_requests 100<span class="p">;</span>
</code></pre></div></div> <h2 id="keepalive-timeout"> <a href="#keepalive-timeout" class="anchor-head"></a> Keepalive Timeout </h2> <p>첫 번째 매개 변수는 유지 관리 클라이언트 연결이 서버 측에서 열려 있는 동안 타임아웃을 설정한다. 0 값은 유지 관리 클라이언트 연결을 비활성화한다. 선택적 두 번째 매개 변수는 “Keep-Alive : timeout=time”응답 헤더 필드의 값을 설정한다. 두 가지 매개변수가 다를 수 있다. “Keep-Alive : timeout=time”헤더 필드는 Mozilla와 Konqueror에 의해 인식된다. MSIE는 약 60초 안에 킵-얼라이브 연결을 스스로 닫는다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keepalive_timeout <span class="nb">timeout</span> <span class="o">[</span>header_timeout]<span class="p">;</span>
keepalive_timeout 75s<span class="p">;</span>
</code></pre></div></div> <h2 id="keepalive"> <a href="#keepalive" class="anchor-head"></a> Keepalive </h2> <p>업스트림 서버에 연결할 캐시를 활성화한다. 연결 매개변수는 각 작업자 프로세스의 캐시에 보존되는 업스트림 서버에 대한 최대 유휴 유지 접속 수를 설정한다. 이 숫자를 초과하면 가장 최근에 사용한 연결이 닫힌다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keepalive connections<span class="p">;</span>

upstream http_backend <span class="o">{</span>
    server 127.0.0.1:8080<span class="p">;</span>
    keepalive 16<span class="p">;</span>
<span class="o">}</span>

server <span class="o">{</span>
    ...

    location /http/ <span class="o">{</span>
        proxy_pass http://http_backend<span class="p">;</span>
        proxy_http_version 1.1<span class="p">;</span>
        proxy_set_header Connection <span class="s2">""</span><span class="p">;</span>
        ...
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="configuring-socket-sharding"> <a href="#configuring-socket-sharding" class="anchor-head"></a> Configuring Socket Sharding </h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http <span class="o">{</span>
     server <span class="o">{</span>
          listen 80 reuseport<span class="p">;</span>
          server_name  localhost<span class="p">;</span>
          <span class="c"># ...</span>
     <span class="o">}</span>
<span class="o">}</span>

stream <span class="o">{</span>
     server <span class="o">{</span>
          listen 12345 reuseport<span class="p">;</span>
          <span class="c"># ...</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="epoll"> <a href="#epoll" class="anchor-head"></a> epoll </h2> <p>Nginx는 non-blocking I/O 방식을 사용하므로 자신에게 요청해온 connection file에 read 가능한지를 계속해서 확인해 주어야 한다.</p> <p>multi-thread 방식에서는 context-switching을 계속 해야 하므로 대량 호출이 발생할 경우, 자원을 많이 사용하게 된다면 non-blocking I/O를 사용하는 single-thread 방식의 Nginx에서는 자신에게 연결되어 있는 socket에 읽을 데이터가 있는지 계속 확인하는데 자원을 낭비할 수 있다고 한다.</p> <p>Nginx에 들어오는 연결이 적을 경우 낭비되는 자원이 크지 않지만, 사용자가 많아질 경우 idle 상태로 연결된 connection이 많다면 이 connection들을 스캔하는 데 많은 자원이 필요하게 되어 그러한 시스템에서는 아래와 같이 설정하도록 권장하고 있다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>events <span class="o">{</span>
    use epoll<span class="p">;</span>
    worker_connections  1024<span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div> <p>위에서 지정한 epoll은 Linux에서 socket을 관리하는 데 사용하는 방식 중 하나로, epoll 외에도 poll, select 방식이 있다.</p> <p>이 중 poll과 select는 해당 프로세스에 연결된 모든 connection file을 스캔하지만, epoll은 수천개의 file descriptor를 처리할 수 있도록 보다 효율적인 알고리즘을 사용하고 있어 대량 요청이 발생하는 시스템에 적합하다고 한다.</p> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/%EC%B9%B4%ED%94%84%EC%B9%B4-%ED%8C%8C%ED%8B%B0%EC%85%98-%EC%88%98-%EC%84%A4%EA%B3%84/" > <div class="nav-arrow">Previous</div> <span class="post-title">카프카 파티션 수 설계</span> </a> <a class="post-nav-item post-nav-next" href="/Nginx-compile-install/"> <div class="nav-arrow">Next</div> <span class="post-title">Nginx Compile Install</span> </a> </nav> <footer class="footer"> <!--<a class="footer_item" href="/thanks">ack.</a> <a class="footer_item" href="javascript::void(0)">resume</a>--> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2022</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
